# 📌 `useCallback` 핵심 정리

## 1. 정의 (Definition)

> **"함수를 메모이제이션(Memoization)하여, 컴포넌트가 리렌더링될 때마다 함수가 새로 만들어지는 것을 방지하는 훅"**

- 리액트 컴포넌트 안에 있는 **함수**는 컴포넌트가 리렌더링 될 때마다 **새로 생성(재선언)**됩니다.
- `useCallback`을 쓰면, 의존성 배열(`deps`)이 바뀌지 않는 한 **"이전에 만들어둔 그 함수 객체"**를 그대로 재사용합니다.

---

## 2. 사용하는 이유

**"함수도 객체(Object)다."** 라는 자바스크립트의 특성 때문입니다.

### 🚨 문제 상황: 참조 동등성(Referential Equality) 문제

1. 컴포넌트가 리렌더링됨.
2. 컴포넌트 내부에 있던 `handleClick` 함수가 **새로 만들어짐**.
3. 내용은 똑같지만, 메모리 주소가 달라졌으므로 **"새로운 함수"**로 취급됨.
4. 이 함수를 자식 컴포넌트(`Child`)에게 Props로 넘겨줌.
5. 자식 컴포넌트(`Child`) 입장: **"어? 엄마가 준 함수가 바뀌었네? (주소가 다름)"**
6. 자식 컴포넌트도 불필요하게 **리렌더링**됨. (비효율!)

### ✅ 해결책

- `useCallback`으로 함수를 묶어두면, 리렌더링이 되어도 **메모리 주소가 같은 기존 함수**를 유지합니다.
- 자식 컴포넌트는 "어? 아까 그 함수네? 안 바뀌었으니 나는 렌더링 안 해야지." (최적화 성공)

---

## 3. useMemo vs useCallback

둘은 형제 같은 관계입니다.

| 구분          | useMemo                                 | useCallback                            |
| :------------ | :-------------------------------------- | :------------------------------------- |
| **저장 대상** | **함수의 결과값 (Return Value)**        | **함수 그 자체 (Function Instance)**   |
| **사용 예시** | `const value = useMemo(() => fn(), [])` | `const fn = useCallback(() => {}, [])` |
| **비유**      | 계산된 **답안지**를 복사해 둠           | 문제를 푸는 **방식(공식)**을 기억해 둠 |

---

## 4. 간단한 예시 (Child 컴포넌트 최적화)

**상황:**
`App` 컴포넌트가 리렌더링될 때, 자식인 `Button` 컴포넌트는 리렌더링될 필요가 없는 상황입니다.

```javascript
import React, { useState, useCallback } from "react";

// 1. 자식 컴포넌트 (React.memo로 감싸야 Props 비교를 함)
const Button = React.memo(({ onClick, children }) => {
  console.log(`${children} 버튼 렌더링 됨! 렌더링 됨!`);
  return <button onClick={onClick}>{children}</button>;
});

function App() {
  const [count, setCount] = useState(0);
  const [toggle, setToggle] = useState(false);

  // ❌ useCallback 없음 (나쁜 예)
  // toggle state가 바뀌어서 App이 리렌더링될 때마다, 이 함수도 새로 만들어짐.
  // -> Button 컴포넌트도 덩달아 리렌더링됨.
  const badFunction = () => {
    console.log("그냥 함수 실행");
  };

  // ✅ useCallback 사용 (좋은 예)
  // 의존성 배열이 [] 비어있으므로, 이 함수는 처음 한 번 만들어지고 절대 안 바뀜.
  // -> Button 컴포넌트는 리렌더링되지 않음!
  const goodFunction = useCallback(() => {
    console.log("최적화된 함수 실행");
  }, []);

  return (
    <div>
      <h1>카운트: {count}</h1>
      {/* 버튼을 누르면 App이 리렌더링됨 */}
      <button onClick={() => setCount(count + 1)}>숫자 증가 (+)</button>
      <button onClick={() => setToggle(!toggle)}>토글 변경</button>

      <hr />

      {/* 자식에게 함수 전달 */}
      <Button onClick={badFunction}>나쁜 버튼 (계속 깜빡임)</Button>
      <Button onClick={goodFunction}>착한 버튼 (안 깜빡임)</Button>
    </div>
  );
}

export default App;
```
