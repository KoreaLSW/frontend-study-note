# 📌 useEffect 핵심 정리

## 1. useEffect란?

`useEffect`는 **컴포넌트를 외부 시스템과 동기화하기 위해 사용되는 Hook**이다.
React는 UI 렌더링만 담당하고, 외부 시스템(네트워크, DOM, 이벤트 리스너, console, 타이머, API요청 등)은 통제하지 않기 때문에, 이를 다루기 위한 “부수효과(Side Effect)”를 처리하는 장치가 필요하다.

➡️ 그 역할을 하는 것이 바로 **useEffect**.

---

## 2. 기본 문법

```jsx
useEffect(() => {
  // effect 실행 코드

  return () => {
    // cleanup 코드 (옵션)
  };
}, [dependencies]);
```

### 👇 역할 설명

- **첫 번째 인자(setup function)**
  effect 내부에서 실행할 동작(데이터 요청, 구독, DOM 조작 등)
- **return의 역할**
  컴포넌트가 언마운트될 때 동작(남아 있는 이벤트 리스너·타이머·구독 등을 제거해야 할때)
- **두 번째 인자(dependencies)**
  특정 값이 변할 때만 effect를 다시 실행하도록 제어

---

## 3. 실행 시점

React는 다음 순서로 동작한다:

1️⃣ 컴포넌트 렌더링
2️⃣ DOM 업데이트
3️⃣ **useEffect 실행**
4️⃣ 다음 effect 실행 전 또는 컴포넌트 언마운트 시 → **return(cleanup) 실행**

즉, **화면이 먼저 렌더되고 effect가 실행**되는 것이 핵심이다.

---

## 4. dependencies(의존성) 동작 방식

### ✔ 생략 시

```js
useEffect(() => {...});
```

➡️ **모든 렌더링마다 실행**

---

### ✔ 빈 배열 `[]`

```js
useEffect(() => {...}, []);
```

➡️ **첫 렌더링(마운트) 시 단 한 번만 실행**

---

### ✔ 값이 들어 있는 경우

```js
useEffect(() => {...}, [value]);
```

➡️ `value`가 변경될 때마다 effect 실행
➡️ 이전 effect는 먼저 cleanup 실행

---

## 5. cleanup이 필요한 이유

cleanup은 “정리함수” 역할을 한다.

### 대표적인 cleanup 상황

- 이벤트 리스너 제거
- WebSocket / subscription 해제
- setInterval / setTimeout 제거
- 요청 취소(AbortController)

### 예시

```js
useEffect(() => {
  // 1초마다 count를 증가시키는 타이머
  const intervalId = setInterval(() => {
    console.log("1초 경과");
  }, 1000);

  // cleanup: 컴포넌트가 언마운트되거나 재실행되기 전 타이머 정리
  return () => {
    clearInterval(intervalId);
  };
}, []);
```

➡️ 이렇게 하지 않으면 **메모리 누수 / 중복 실행 / 예기치 않은 버그**가 발생함.

---

## 6. 대표적 사용 예시

### (1) 데이터 패칭

```js
useEffect(() => {
  fetch("/api/data")
    .then((res) => res.json())
    .then(setData);
}, []);
```

---

### (2) 이벤트 리스너 등록

```js
useEffect(() => {
  const onScroll = () => {...};
  window.addEventListener('scroll', onScroll);

  return () => {
    window.removeEventListener('scroll', onScroll);
  };
}, []);
```

---

### (3) 의존성 기반 업데이트

```js
useEffect(() => {
  console.log("userId changed:", userId);
}, [userId]);
```

---

## 7. 자주 하는 실수 & 주의할 점

### ❌ 1) 의존성 누락

특정 state/props를 dependencies에 넣지 않으면 stale 값이 사용됨.

### ❌ 2) 객체/함수/배열을 의존성에 넣어 무한 반복

매 렌더마다 참조값이 바뀌기 때문에 effect가 계속 실행됨.

```js
useEffect(() => {...}, [{}]); // 절대 넣으면 안 됨
```

➡️ 해결: useCallback, useMemo로 메모이제이션

---

### ❌ 3) cleanup 누락

구독/interval/timer가 그대로 남아서 메모리 누수 발생.

---

### ❌ 4) effect에서 setState하는데 해당 state가 dependencies에 있을 때 무한 루프

```js
useEffect(() => {
  setCount(count + 1);
}, [count]); // 무한 렌더링
```

➡️ 해결: 조건문 또는 함수형 업데이트 사용
