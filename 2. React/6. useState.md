# 📌 `useState` 핵심 정리

리액트 개발의 8할은 `useState`라고 해도 과언이 아닙니다.
하지만 단순히 **값을 저장하고 변경하는 변수**라고 생각하고 쓰다가는 예상치 못한 버그를 만나게 됩니다.

이 문서는 `setState`의 **정의, 동작 원리, 그리고 흔히 하는 실수**를 정리한 노트입니다.

---

설명에 앞서서 useState의 구조를 한번 확인해보겠습니다.

```javascript
const [count, setCount] = useState(0);
```

#### 1\. `useState(0)`의 파라미터 (`0`)

> **역할: 초기값 (Initial Value)**

- **의미:** "이 컴포넌트가 **맨 처음** 화면에 나타날 때, `count`의 값을 **0**으로 시작해라."
- **특징:** 이 값은 **첫 렌더링 시에만** 사용됩니다. 나중에 `setCount`로 값이 바뀌면, 리액트는 이 초기값(0)을 무시하고 바뀐 최신 값을 사용합니다.

#### 2\. `count` (첫 번째 반환값)

> **역할: 현재 상태 값 (Current State)**

- **의미:** 현재 시점의 데이터가 들어있는 **변수**입니다.
- **사용:** 화면에 보여주거나(`{count}`), 계산할 때 사용합니다.
- **주의:** 이 변수는 **읽기 전용(Read-only)** 처럼 다뤄야 합니다. `count = 5`처럼 직접 수정하면 안 됩니다.

#### 3\. `setCount` (두 번째 반환값)

> **역할: 상태 변경 함수 (Setter Function)**

- **의미:** `count` 값을 바꿀 수 있는 \*\*유일한 수단(함수)\*\*입니다.
- **동작:** 이 함수를 실행하면(`setCount(5)`), 리액트는 **"아, 값이 바뀌었으니 화면을 다시 그려야겠네?"** 하고 리렌더링을 시작합니다.
- **작명 규칙:** 앞의 변수명 앞에 `set`을 붙이고 카멜 케이스로 짓는 것이 관례입니다. (예: `name` -\> `setName`)

---

## 1. `setState`

> **"값이 바뀌면 화면을 다시 그려달라고 리액트에게 요청(Request)하는 함수"**

단순히 변수 값을 바꾸는 게 아닙니다.
`setState`가 호출되면 리액트는 **"아, 데이터가 바뀌었네? 이 컴포넌트랑 자식들 전부 다시 그려야겠다(Re-render)"** 라고 판단하고 일을 시작합니다.

### 💡 코드로 보는 올바른 사용법

#### ① 기본 값 변경 (숫자, 문자열 등)

변수에 값을 대입(`=`)하는 것이 아니라, 반드시 `Setter` 함수를 써야 합니다.

```javascript
const [count, setCount] = useState(0);

// ❌ 틀린 예 (직접 수정)
// 리액트는 count 변수가 100으로 바뀐지 전혀 모름. 화면 갱신 안 됨.
count = 100;

// ✅ 올바른 예 (Setter 사용)
// "count를 100으로 바꾸고 화면 다시 그려줘!"라고 요청함.
setCount(100);
```

#### ② 객체/배열 변경 (참조 타입) ✨ **중요**

기존 객체를 수정하는 게 아니라, **새로운 객체를 만들어서** 갈아 끼워야 합니다. (불변성 유지)

```javascript
const [user, setUser] = useState({ name: "Cheolsu", age: 20 });

// ❌ 틀린 예 (원본 객체 직접 수정)
// 주소가 같은 객체를 다시 넣었기 때문에, React가 이전 값과 새 값을 비교했을 때 달라지지 않은 걸로 판단해서 렌더링을 건너뛴다
user.age = 30;
setUser(user);

// ✅ 올바른 예 (새 객체 생성 - Spread 문법)
// 기존 내용을 복사(...)하고 age만 덮어쓴 '새 객체'를 전달함.
setUser({ ...user, age: 30 });
```

## 2. 실전 문제: 왜 숫자가 1만 증가할까? 🤔

### ❌ 문제 상황

아래 코드를 실행하면 `setNumber`를 5번이나 불렀는데, 버튼을 누르면 숫자가 **1씩만 증가**합니다. (5가 아니라!)

```javascript
const handleAdd = () => {
  // 현재 number가 0이라고 가정
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
};
```

### 🔍 원인 1: 스냅샷 (Snapshot) 📸

리액트가 컴포넌트를 렌더링할 때, 그 순간의 \*\*State 값은 고정(Snapshot)\*\*되어 있습니다.

- 함수가 실행되는 동안 `number` 변수는 **계속 0**입니다. (실시간으로 변하지 않음)
- 즉, 위 코드는 **`setNumber(0 + 1)`** 이라는 똑같은 명령만 5번 내린 셈이 됩니다.

### 🔍 원인 2: 배칭 (Batching) 📦

리액트는 성능을 위해 `setState`를 만날 때마다 렌더링하지 않고, **모아서 한꺼번에 처리**합니다.

1.  주문 접수: "1로 바꿔", "1로 바꿔", ... (5번 반복)
2.  리액트의 판단: "결국 1로 바꾸라는 소리네?"
3.  **최종적으로 딱 1번만 렌더링**하고 값은 1이 됩니다.

---

## 3\. 해결책: 함수형 업데이트 (Functional Update) ✨

이전 값(Previous State)을 확실하게 반영해서 계산하고 싶다면, 값을 바로 넣지 말고 **함수**를 넣어야 합니다.

```javascript
const handleAdd = () => {
  // prev: 리액트가 내부적으로 기억하고 있는 '가장 최신 state'
  setNumber((prev) => prev + 1); // 0 -> 1
  setNumber((prev) => prev + 1); // 1 -> 2
  setNumber((prev) => prev + 1); // 2 -> 3
  setNumber((prev) => prev + 1); // 3 -> 4
  setNumber((prev) => prev + 1); // 4 -> 5
};
```

> **💡 언제 함수형을 써야 할까?**
>
> - 위 예시처럼 연속으로 상태를 업데이트할 때
> - 현재 값이 아니라 **"이전 값"에 의존해서** 새 값을 계산해야 할 때

---

## 4. ⚠️ `setState` (Hooks) 사용 시 주의할 점 4가지

### ① 비동기적으로 동작함 (즉시 반영 안 됨)

`setState`를 호출한 직후에 콘솔을 찍어보면 값이 안 바뀌어 있습니다.

```javascript
const handleClick = () => {
  setCount(100);
  console.log(count); // 😱 여전히 0이 나옴 (100 아님!)
};
```

- **이유:** 리액트가 업데이트를 스케줄링해두고 나중에 처리하기 때문입니다.
- **해결:** setState 이후의 최신 값은 다음 렌더링에서 사용 가능하고, 값이 바뀐 후에 로그를 찍거나 외부 작업을 하고 싶다면 useEffect를 사용해 감지한다

### ② 불변성(Immutability)을 지켜야 함

리액트는 **"메모리 주소(참조값)"가 바뀌어야** 변화를 감지합니다.
기존 객체나 배열을 직접 수정하면 리액트는 모릅니다.

```javascript
const [user, setUser] = useState({ name: "Kim", age: 20 });

// ❌ 잘못된 방법 (화면 안 바뀜)
user.age = 21;
setUser(user); // "주소가 그대로네? 안 바꿀래."

// ✅ 올바른 방법 (Spread 연산자로 새 객체 만들기)
setUser({ ...user, age: 21 });
```

### ③ 값이 같으면 렌더링 안 함 (Bailout)

`setState`로 10을 넣었는데, 현재 값도 이미 10이라면?
리액트는 똑똑해서 굳이 화면을 다시 그리는 낭비를 하지 않습니다.

### ④ 조건문/반복문 안에서 선언 금지 (Hook 규칙)

`useState`를 포함한 모든 훅은 반드시 컴포넌트의 \*\*최상위(Top Level)\*\*에서만 선언해야 합니다.
`if`문, `for`문, 일반 함수 안에서 선언하면 안 됩니다.

```javascript
// ❌ 절대 안 됨 (조건에 따라 Hook 실행 순서가 달라짐)
if (isLoggedIn) {
  const [name, setName] = useState("Kim");
}

// ✅ 무조건 최상위에서 선언하고 로직을 처리해야 함
const [name, setName] = useState("Kim");
```

- **이유:** 리액트는 훅이 \*\*호출되는 순서(index)\*\*를 기억해서 각 state를 구분합니다. 조건문에 따라 훅이 실행됐다 안 됐다 하면 순서가 꼬여서 치명적인 버그가 발생합니다.

## 📝 요약 노트

| 구분              | 코드 예시                     | 언제 쓰나?                   |
| :---------------- | :---------------------------- | :--------------------------- |
| **값 업데이트**   | `setNumber(10)`               | 그냥 값을 바꿀 때            |
| **함수 업데이트** | `setNumber(prev => prev + 1)` | 이전 값을 기준으로 계산할 때 |

1.  `setState`는 **리렌더링 트리거**다.
2.  변수처럼 즉시 바뀌지 않는다 (**비동기**).
3.  연속 계산이 필요하면 무조건 **함수형 업데이트**를 쓰자.
4.  객체/배열은 \*\*불변성(복사본 만들기)\*\*을 꼭 지키자.
