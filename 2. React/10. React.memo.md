# 📌 React.memo (`memo`) 핵심 정리

## 1. 정의 (Definition)

> **"부모 컴포넌트가 리렌더링되어도, 내 Props가 바뀌지 않았다면 나는 리렌더링 하지 마!"**

- `React.memo`는 훅(Hook)이 아니라 **고차 컴포넌트 (Higher Order Component, HOC)**입니다.
- 컴포넌트를 **감싸는(Wrapping)** 형태로 사용합니다.
- 컴포넌트의 **렌더링 결과**를 메모이징(Memoization)합니다.

---

## 2. 사용하는 이유 (Why?)

리액트의 기본 동작 원칙 중 하나는 **부모가 리렌더링되면 자식도 무조건 리렌더링된다**입니다.

### 🚨 문제 상황

1. 부모 컴포넌트에 `text`와 `count`라는 상태가 있음.
2. 자식 컴포넌트는 `text`만 Props로 받아서 보여줌.
3. 부모에서 `count`를 변경함.
4. 부모가 리렌더링되니, **`count`와 전혀 상관없는 자식 컴포넌트도 덩달아 리렌더링됨.** (낭비!)

### ✅ 해결책 (`React.memo`)

- 자식 컴포넌트를 `memo`로 감싸주면, 리액트가 **Props 변화를 감시**합니다.
- "어? 부모는 다시 그려졌는데, 자식이 받는 `text` Props는 그대로네? **자식은 다시 그리지 말고 아까 거 그대로 써!**"

---

## 3. 사용법

컴포넌트를 정의하고 내보낼 때(`export`) `React.memo`로 감싸주면 끝입니다.

```javascript
import React from "react";

// 자식 컴포넌트
const Child = ({ name }) => {
  console.log("👶 자식 렌더링!");
  return <div>안녕하세요, {name}님!</div>;
};

// 이렇게 감싸면 최적화 완료!
export default React.memo(Child);
```

---

## 4\. ⚠️ 주의사항: "왜 memo를 썼는데도 리렌더링 되나요?"

이게 가장 중요한 포인트입니다. **Props로 객체나 함수를 넘길 때** 실수가 많이 발생합니다.

### 얕은 비교 (Shallow Compare)의 함정

`React.memo`는 Props가 바뀌었는지 확인할 때 **얕은 비교**(`===`)만 합니다.

1.  **원시값(Number, String)** 비교:

    - `1 === 1` (True) 👉 **렌더링 안 함 (성공)**

2.  **참조값(Object, Array, Function)** 비교:

    - 부모가 리렌더링되면 객체나 함수는 \*\*새로 생성(새 주소값 할당)\*\*됩니다.
    - `{ a: 1 } === { a: 1 }` (False) 👉 **내용은 같아도 주소가 달라서 렌더링 함 (실패)**

### 💡 해결책: 3대장 합체

그래서 `React.memo`를 제대로 쓰려면 부모 컴포넌트에서 `useMemo`와 `useCallback`을 같이 써야 합니다.

- **함수 Props:** `useCallback`으로 감싸서 전달.
- **객체 Props:** `useMemo`로 감싸서 전달.

<!-- end list -->

```javascript
// 부모 컴포넌트
function Parent() {
  // ❌ 나쁜 예: 부모 렌더링 때마다 새로운 함수 생성 -> Child의 memo가 깨짐
  const handleClick = () => {
    console.log("클릭");
  };

  // ✅ 좋은 예: useCallback으로 함수 재사용 -> Child의 memo가 작동함
  const handledClickMemo = useCallback(() => {
    console.log("클릭");
  }, []);

  return (
    // 자식에게 최적화된 함수 전달
    <Child onClick={handledClickMemo} />
  );
}
```

---

## 5\. 요약 비교 (최적화 3형제)

| 이름            | 대상                | 역할                                 | 비유                                       |
| :-------------- | :------------------ | :----------------------------------- | :----------------------------------------- |
| **React.memo**  | **컴포넌트**        | 컴포넌트 자체의 불필요한 렌더링 방지 | **방탄조끼** (부모의 렌더링 공격을 막아줌) |
| **useMemo**     | **값 (Value)**      | 복잡한 계산 결과 재사용              | **컨닝 페이퍼** (답을 적어두고 베낌)       |
| **useCallback** | **함수 (Function)** | 함수 선언 재사용 (Props 전달용)      | **박제** (함수를 박제해서 변하지 않게 함)  |
