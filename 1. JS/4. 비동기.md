# JavaScript 비동기 프로그래밍

JavaScript는 단일 스레드 환경에서 동작하지만, 비동기 프로그래밍을 통해 효율적으로 작업을 처리할 수 있습니다. 비동기 처리의 발전 과정과 핵심 개념을 알아보겠습니다.

## 비동기 프로그래밍이란?

**비동기(Asynchronous)** 프로그래밍은 작업을 순차적으로 기다리지 않고, 다른 작업을 수행하면서 결과를 기다리는 방식입니다.

### 동기 vs 비동기

**동기(Synchronous) 방식:**

- 작업이 순차적으로 실행됨
- 한 작업이 끝날 때까지 다음 작업을 기다림
- 블로킹(Blocking) 방식

```javascript
// 동기 방식 예시
console.log("1");
console.log("2");
console.log("3");
// 출력: 1, 2, 3 (순서대로)
```

**비동기(Asynchronous) 방식:**

- 작업이 병렬로 실행될 수 있음
- 작업이 끝나기를 기다리지 않고 다음 작업 수행
- 논블로킹(Non-blocking) 방식

```javascript
// 비동기 방식 예시
console.log("시작");

setTimeout(() => {
  console.log("비동기 작업 완료");
}, 1000);

console.log("끝");

// 출력:
// 시작
// 끝
// 비동기 작업 완료 (1초 후)
```

### 비동기가 필요한 이유

- **사용자 경험 향상**: 네트워크 요청 중에도 UI가 멈추지 않음
- **성능 최적화**: 여러 작업을 동시에 처리 가능
- **효율적인 리소스 활용**: 대기 시간 동안 다른 작업 수행

## 1. JavaScript 실행 환경

JavaScript의 비동기 처리를 이해하기 위해서는 JavaScript 엔진의 실행 환경을 먼저 알아야 합니다.

### JavaScript 엔진의 구성 요소

JavaScript는 다음 네 가지 핵심 요소로 구성됩니다:

1. **Memory Heap (메모리 힙)**
2. **Call Stack (콜 스택)**
3. **Event Loop (이벤트 루프)**
4. **Task Queue (태스크 큐)**

### Memory Heap (메모리 힙)

**메모리 힙**은 객체, 배열, 함수 등이 저장되는 메모리 영역입니다.

```javascript
// 객체는 힙에 저장됨
const person = { name: "철수", age: 30 };
const numbers = [1, 2, 3, 4, 5];
const func = function () {
  console.log("함수");
};
```

**특징:**

- 동적으로 할당된 메모리 영역
- 객체와 참조 타입 데이터 저장
- 가비지 컬렉션(Garbage Collection)으로 관리

### Call Stack (콜 스택)

**콜 스택**은 함수 호출이 쌓이는 스택 구조입니다. JavaScript는 단일 스레드이므로 하나의 콜 스택만 존재합니다.

```javascript
function first() {
  console.log("첫 번째 함수");
  second();
}

function second() {
  console.log("두 번째 함수");
  third();
}

function third() {
  console.log("세 번째 함수");
}

first();

// 콜 스택 상태:
// [third]     <- 가장 위
// [second]
// [first]
// [global]    <- 가장 아래
```

**동작 방식:**

1. 함수가 호출되면 콜 스택에 추가됨
2. 함수 실행이 끝나면 콜 스택에서 제거됨
3. 스택이 비어있으면 프로그램 종료

**예시:**

```javascript
function multiply(a, b) {
  return a * b;
}

function add(a, b) {
  const result = multiply(a, b);
  return result + 10;
}

const answer = add(3, 4);
console.log(answer); // 22

// 실행 순서:
// 1. add() 호출 → 콜 스택에 추가
// 2. multiply() 호출 → 콜 스택에 추가
// 3. multiply() 완료 → 콜 스택에서 제거
// 4. add() 완료 → 콜 스택에서 제거
```

### Event Loop (이벤트 루프)

**이벤트 루프**는 콜 스택과 태스크 큐를 연결하는 핵심 메커니즘입니다.

**역할:**

1. 콜 스택이 비어있는지 지속적으로 확인
2. 콜 스택이 비면 태스크 큐에서 대기 중인 작업을 가져와 실행
3. 이 과정을 반복

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");

// 실행 과정:
// 1. console.log("1") → 콜 스택에 추가 후 실행
// 2. setTimeout → Web API로 전달, 콜백은 태스크 큐에 추가
// 3. console.log("3") → 콜 스택에 추가 후 실행
// 4. 콜 스택이 비면 이벤트 루프가 태스크 큐 확인
// 5. 콜백 함수 실행 → console.log("2")

// 출력: 1, 3, 2
```

**이벤트 루프의 동작 원리:**

```
┌─────────────────┐
│   Call Stack    │ ← 함수 실행
└────────┬────────┘
         │
         │ (비어있으면)
         ↓
┌─────────────────┐
│  Event Loop     │ ← 지속적으로 확인
└────────┬────────┘
         │
         │ (작업 가져오기)
         ↓
┌─────────────────┐
│   Task Queue    │ ← 비동기 콜백 대기
└─────────────────┘
```

### Task Queue (태스크 큐)

**태스크 큐**는 비동기 작업의 콜백 함수가 대기하는 큐입니다.

**종류:**

1. **Macrotask Queue (매크로태스크 큐)**

   - `setTimeout`, `setInterval` 콜백
   - 이벤트 핸들러
   - I/O 작업

2. **Microtask Queue (마이크로태스크 큐)**
   - `Promise.then()` 콜백
   - `queueMicrotask()` 콜백
   - `MutationObserver` 콜백

**실행 순서:**

```javascript
console.log("1");

// 매크로태스크
setTimeout(() => console.log("2"), 0);

// 마이크로태스크
Promise.resolve().then(() => console.log("3"));

console.log("4");

// 출력: 1, 4, 3, 2
// 이유: 마이크로태스크가 매크로태스크보다 우선순위가 높음
```

### 전체 실행 흐름 예시

```javascript
console.log("시작");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("끝");

// 실행 흐름:
// 1. 콜 스택: [console.log("시작")] → 실행 → "시작" 출력
// 2. 콜 스택: [setTimeout] → Web API로 전달 → 매크로태스크 큐에 콜백 추가
// 3. 콜 스택: [Promise.resolve().then] → 마이크로태스크 큐에 콜백 추가
// 4. 콜 스택: [console.log("끝")] → 실행 → "끝" 출력
// 5. 콜 스택이 비어있음
// 6. 이벤트 루프: 마이크로태스크 큐 확인 → Promise 콜백 실행 → "Promise" 출력
// 7. 이벤트 루프: 매크로태스크 큐 확인 → setTimeout 콜백 실행 → "setTimeout" 출력

// 최종 출력: 시작, 끝, Promise, setTimeout
```

## 2. 콜백 함수와 콜백 지옥

### 콜백 함수란?

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수입니다.

```javascript
// 간단한 콜백 예시
function greet(name, callback) {
  console.log(`안녕하세요, ${name}님!`);
  callback();
}

greet("철수", function () {
  console.log("콜백 함수가 실행되었습니다.");
});
// 출력:
// 안녕하세요, 철수님!
// 콜백 함수가 실행되었습니다.
```

### 비동기 콜백

```javascript
// setTimeout을 사용한 비동기 콜백
console.log("시작");

setTimeout(function () {
  console.log("1초 후 실행");
}, 1000);

console.log("끝");

// 출력 순서:
// 시작
// 끝
// 1초 후 실행
```

### 콜백 지옥(Callback Hell)

여러 비동기 작업을 순차적으로 처리할 때 콜백이 중첩되어 코드가 복잡해지는 현상을 콜백 지옥이라고 합니다.

```javascript
// 콜백 지옥 예시
getData(function (data1) {
  processData(data1, function (data2) {
    saveData(data2, function (data3) {
      sendData(data3, function (response) {
        console.log("완료:", response);
        // 더 많은 중첩...
      });
    });
  });
});
```

**문제점:**

- 코드 가독성 저하
- 에러 처리 어려움
- 디버깅 복잡
- 유지보수 어려움

## 3. Promise

Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체로, 콜백 지옥 문제를 해결합니다.

### Promise 생성

```javascript
// Promise 생성자 사용
const promise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  setTimeout(() => {
    const success = true;
    if (success) {
      // 작업이 성공했을때 resolve()를 호출
      resolve("작업 성공!");
    } else {
      // 작업이 실패했을때 reject()를 호출
      reject("작업 실패!");
    }
  }, 1000);
});

// Promise 사용
promise
  .then((result) => {
    console.log(result); // "작업 성공!"
  })
  .catch((error) => {
    console.error(error); // "작업 실패!"
  });
```

### Promise 상태

Promise는 세 가지 상태를 가집니다:

- **pending**: 대기 중 (초기 상태)
- **fulfilled**: 성공 (resolve 호출)
- **rejected**: 실패 (reject 호출)

### Promise 체이닝

여러 비동기 작업을 순차적으로 처리할 수 있습니다.

```javascript
// Promise 체이닝 예시
function fetchEgg(chicken) {
  return Promise.resolve(`${chicken} => 🥚`);
}

function fryEgg(egg) {
  return Promise.resolve(`${egg} => 🍳`);
}

function getChicken() {
  return Promise.resolve(`☘️ => 🐓`);
}

getChicken()
  .then((chicken) => fetchEgg(chicken))
  .then((egg) => fryEgg(egg))
  .then((friedEgg) => console.log(friedEgg));

// console.log(☘️ => 🐓 => 🥚 => 🍳)
```

### Promise.all

여러 Promise를 병렬로 실행하고 모두 완료될 때까지 기다립니다.

```javascript
const promise1 = fetch("/api/user/1");
const promise2 = fetch("/api/user/2");
const promise3 = fetch("/api/user/3");

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log("모든 요청 완료:", results);
    // results는 [response1, response2, response3] 배열
  })
  .catch((error) => {
    console.error("하나라도 실패:", error);
    // 하나라도 실패하면 catch로 이동
  });
```

**특징:**

- 모든 Promise가 성공해야 `then` 실행
- 하나라도 실패하면 `catch` 실행
- 결과는 입력 순서대로 배열로 반환

### Promise.race

여러 Promise 중 가장 먼저 완료되는 것의 결과를 반환합니다.

```javascript
const promise1 = new Promise((resolve) =>
  setTimeout(() => resolve("첫 번째"), 2000)
);
const promise2 = new Promise((resolve) =>
  setTimeout(() => resolve("두 번째"), 1000)
);
const promise3 = new Promise((resolve) =>
  setTimeout(() => resolve("세 번째"), 3000)
);

Promise.race([promise1, promise2, promise3]).then((result) => {
  console.log(result); // "두 번째" (가장 빨리 완료)
});
```

**활용 예시:**

```javascript
// 타임아웃 구현
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("타임아웃")), timeout)
  );

  return Promise.race([fetchPromise, timeoutPromise]);
}

fetchWithTimeout("/api/data", 3000)
  .then((response) => console.log("성공:", response))
  .catch((error) => console.error("실패:", error));
```

### Promise.allSettled

모든 Promise가 완료될 때까지 기다리며, 성공/실패 여부와 관계없이 모든 결과를 반환합니다.

```javascript
const promise1 = Promise.resolve("성공1");
const promise2 = Promise.reject("실패");
const promise3 = Promise.resolve("성공2");

Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`Promise ${index + 1} 성공:`, result.value);
    } else {
      console.log(`Promise ${index + 1} 실패:`, result.reason);
    }
  });
});
```

## 4. async/await

`async/await`는 Promise를 더 간결하고 동기 코드처럼 작성할 수 있게 해주는 문법입니다.

### 기본 사용법

```javascript
// async 함수 선언
async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    const user = await response.json();
    return user;
  } catch (error) {
    console.error("에러 발생:", error);
    throw error;
  }
}

// 사용
fetchUserData(1)
  .then((user) => console.log(user))
  .catch((error) => console.error(error));
```

### async 함수 특징

- `async` 함수는 항상 Promise를 반환합니다
- `await`는 Promise가 완료될 때까지 기다립니다
- `await`는 `async` 함수 내부에서만 사용 가능합니다

```javascript
async function example() {
  return "Hello"; // 자동으로 Promise.resolve("Hello")로 감싸짐
}

example().then((result) => console.log(result)); // "Hello"
```

### 순차 처리 vs 병렬 처리

```javascript
// 순차 처리 (느림)
async function sequential() {
  const user = await fetchUser(1); // 1초 대기
  const posts = await fetchPosts(user.id); // 1초 대기
  const comments = await fetchComments(posts[0].id); // 1초 대기
  // 총 3초 소요
}

// 병렬 처리 (빠름)
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(1),
    fetchPosts(1),
    fetchComments(1),
  ]);
  // 총 1초 소요 (가장 오래 걸리는 작업 시간)
}
```

### 에러 처리

```javascript
// try-catch 사용
async function handleError() {
  try {
    const data = await fetchData();
    return data;
  } catch (error) {
    console.error("에러 처리:", error);
    // 에러를 다시 던지거나 기본값 반환
    return null;
  }
}

// 또는 catch 메서드 사용
async function handleError2() {
  const data = await fetchData().catch((error) => {
    console.error("에러:", error);
    return null; // 기본값 반환
  });
  return data;
}
```

### 실전 예시

```javascript
// 여러 API 호출 조합
async function getUserProfile(userId) {
  try {
    const [user, posts, followers] = await Promise.all([
      fetch(`/api/users/${userId}`).then((r) => r.json()),
      fetch(`/api/users/${userId}/posts`).then((r) => r.json()),
      fetch(`/api/users/${userId}/followers`).then((r) => r.json()),
    ]);

    return {
      user,
      posts,
      followers,
      postCount: posts.length,
      followerCount: followers.length,
    };
  } catch (error) {
    console.error("프로필 로드 실패:", error);
    throw error;
  }
}
```

## 5. 이벤트 루프(Event Loop) 심화

이벤트 루프의 동작 원리는 1번 섹션에서 설명했지만, 더 자세한 동작 원리를 알아보겠습니다.

### 이벤트 루프 동작 원리 심화

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

Promise.resolve().then(() => {
  console.log("3");
});

console.log("4");

// 출력 순서: 1, 4, 3, 2
```

**실행 과정:**

1. `console.log("1")` 실행 → 콜 스택에 추가 후 즉시 실행
2. `setTimeout` 실행 → Web API로 전달, 콜백은 매크로태스크 큐에 추가
3. `Promise.resolve().then()` 실행 → 콜백은 마이크로태스크 큐에 추가
4. `console.log("4")` 실행 → 콜 스택에 추가 후 즉시 실행
5. 콜 스택이 비면 이벤트 루프가 마이크로태스크 큐 확인 → `console.log("3")` 실행
6. 마이크로태스크 큐가 비면 매크로태스크 큐 확인 → `console.log("2")` 실행

### 이벤트 루프의 역할

1. 콜 스택이 비어있는지 확인
2. 마이크로태스크 큐 확인 → 있으면 모두 실행
3. 매크로태스크 큐 확인 → 있으면 하나 실행
4. 1번으로 돌아가 반복

## 6. 마이크로태스크 vs 매크로태스크

### 마이크로태스크(Microtask)

**우선순위가 높은** 비동기 작업입니다.

**생성 방법:**

- `Promise.then()`, `Promise.catch()`, `Promise.finally()`
- `queueMicrotask()`
- `MutationObserver`

**특징:**

- 콜 스택이 비면 **즉시** 실행
- 마이크로태스크 큐가 **완전히 비워질 때까지** 계속 실행
- 매크로태스크보다 **우선순위가 높음**

```javascript
console.log("1");

setTimeout(() => console.log("2"), 0); // 매크로태스크

Promise.resolve().then(() => {
  console.log("3");
  Promise.resolve().then(() => console.log("4")); // 마이크로태스크
});

console.log("5");

// 출력: 1, 5, 3, 4, 2
```

### 매크로태스크(Macrotask)

**일반적인** 비동기 작업입니다.

**생성 방법:**

- `setTimeout`, `setInterval`
- `setImmediate` (Node.js)
- I/O 작업
- UI 렌더링

**특징:**

- 마이크로태스크가 모두 실행된 후 실행
- 한 번에 **하나씩** 실행
- 브라우저 렌더링 전에 실행될 수 있음

### 실행 순서 비교

```javascript
console.log("시작");

// 매크로태스크
setTimeout(() => console.log("setTimeout 1"), 0);
setTimeout(() => console.log("setTimeout 2"), 0);

// 마이크로태스크
Promise.resolve().then(() => console.log("Promise 1"));
Promise.resolve().then(() => console.log("Promise 2"));

console.log("끝");

// 출력 순서:
// 시작
// 끝
// Promise 1
// Promise 2
// setTimeout 1
// setTimeout 2
```

### 중첩된 경우

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
  setTimeout(() => console.log("4"), 0);
}, 0);

Promise.resolve().then(() => {
  console.log("5");
  setTimeout(() => console.log("6"), 0);
});

console.log("7");

// 출력: 1, 7, 5, 2, 3, 6, 4
```

## 7. setTimeout과 setInterval

### setTimeout

지정된 시간 후에 함수를 한 번 실행합니다.

```javascript
// 기본 사용법
setTimeout(() => {
  console.log("3초 후 실행");
}, 3000);

// 함수에 인자 전달
function greet(name, message) {
  console.log(`${name}님, ${message}`);
}

setTimeout(greet, 1000, "철수", "안녕하세요!");
// 1초 후: "철수님, 안녕하세요!"
```

### setInterval

지정된 시간마다 함수를 반복 실행합니다.

```javascript
// 1초마다 실행
const intervalId = setInterval(() => {
  console.log("1초마다 실행");
}, 1000);

// 5초 후 중지
setTimeout(() => {
  clearInterval(intervalId);
  console.log("중지됨");
}, 5000);
```

### 동작 방식

```javascript
console.log("시작");

setTimeout(() => {
  console.log("setTimeout 실행");
}, 0);

console.log("끝");

// 출력:
// 시작
// 끝
// setTimeout 실행
```

**이유:**

- `setTimeout`은 비동기로 동작
- 콜백은 매크로태스크 큐에 추가됨
- 현재 실행 중인 코드가 모두 끝난 후 실행

### 주의사항

```javascript
// 최소 지연 시간은 4ms (브라우저 환경)
setTimeout(() => console.log("실행"), 0);
// 실제로는 약 4ms 후 실행될 수 있음

// 정확한 타이밍이 필요한 경우
function preciseTimeout(callback, delay) {
  const start = performance.now();
  function check() {
    if (performance.now() - start >= delay) {
      callback();
    } else {
      requestAnimationFrame(check);
    }
  }
  requestAnimationFrame(check);
}
```

### 실전 활용

```javascript
// 디바운싱 (Debouncing)
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// 사용 예시: 검색 입력
const searchInput = document.getElementById("search");
const debouncedSearch = debounce((query) => {
  console.log("검색:", query);
}, 300);

searchInput.addEventListener("input", (e) => {
  debouncedSearch(e.target.value);
});

// 쓰로틀링 (Throttling)
function throttle(func, delay) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}

// 사용 예시: 스크롤 이벤트
const throttledScroll = throttle(() => {
  console.log("스크롤 이벤트");
}, 100);

window.addEventListener("scroll", throttledScroll);
```

### clearTimeout과 clearInterval

```javascript
// setTimeout 취소
const timeoutId = setTimeout(() => {
  console.log("실행되지 않음");
}, 5000);

clearTimeout(timeoutId); // 취소

// setInterval 중지
let count = 0;
const intervalId = setInterval(() => {
  count++;
  console.log(`카운트: ${count}`);
  if (count >= 5) {
    clearInterval(intervalId);
    console.log("중지됨");
  }
}, 1000);
```

## 요약

- **비동기 프로그래밍**: 작업을 순차적으로 기다리지 않고 병렬로 처리하는 방식
- **Memory Heap**: 객체와 참조 타입 데이터가 저장되는 메모리 영역
- **Call Stack**: 함수 호출이 쌓이는 스택 구조 (단일 스레드)
- **Event Loop**: 콜 스택과 태스크 큐를 연결하는 핵심 메커니즘
- **Task Queue**: 비동기 작업의 콜백 함수가 대기하는 큐 (마이크로태스크/매크로태스크)
- **콜백 함수**: 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수
- **콜백 지옥**: 중첩된 콜백으로 인한 코드 복잡성 문제
- **Promise**: 비동기 작업의 성공/실패를 처리하는 객체
- **async/await**: Promise를 더 간결하게 작성할 수 있는 문법
- **마이크로태스크**: Promise, queueMicrotask 등 (우선순위 높음)
- **매크로태스크**: setTimeout, setInterval 등 (우선순위 낮음)
- **setTimeout/setInterval**: 지연 실행 및 반복 실행을 위한 타이머 함수
