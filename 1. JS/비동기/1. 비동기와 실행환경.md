# JavaScript 비동기 프로그래밍

JavaScript는 단일 스레드 환경에서 동작하지만, 비동기 프로그래밍을 통해 효율적으로 작업을 처리할 수 있습니다. 비동기 처리의 발전 과정과 핵심 개념을 알아보겠습니다.

## 비동기 프로그래밍이란?

**비동기(Asynchronous)** 프로그래밍은 작업을 순차적으로 기다리지 않고, 다른 작업을 수행하면서 결과를 기다리는 방식입니다.

### 동기 vs 비동기

**동기(Synchronous) 방식:**

- 작업이 순차적으로 실행됨
- 한 작업이 끝날 때까지 다음 작업을 기다림
- 블로킹(Blocking) 방식

```javascript
// 동기 방식 예시
console.log("1");
console.log("2");
console.log("3");
// 출력: 1, 2, 3 (순서대로)
```

**비동기(Asynchronous) 방식:**

- 작업이 병렬로 실행될 수 있음
- 작업이 끝나기를 기다리지 않고 다음 작업 수행
- 논블로킹(Non-blocking) 방식

```javascript
// 비동기 방식 예시
console.log("시작");

setTimeout(() => {
  console.log("비동기 작업 완료");
}, 1000);

console.log("끝");

// 출력:
// 시작
// 끝
// 비동기 작업 완료 (1초 후)
```

### 비동기가 필요한 이유

- **사용자 경험 향상**: 네트워크 요청 중에도 UI가 멈추지 않음
- **성능 최적화**: 여러 작업을 동시에 처리 가능
- **효율적인 리소스 활용**: 대기 시간 동안 다른 작업 수행

## 1. JavaScript 실행 환경

JavaScript의 비동기 처리를 이해하기 위해서는 JavaScript 엔진의 실행 환경을 먼저 알아야 합니다.

### JavaScript 엔진의 구성 요소

JavaScript는 다음 네 가지 핵심 요소로 구성됩니다:

1. **Memory Heap (메모리 힙)**
2. **Call Stack (콜 스택)**
3. **Event Loop (이벤트 루프)**
4. **Task Queue (태스크 큐)**

### Memory Heap (메모리 힙)

**메모리 힙**은 객체, 배열, 함수 등이 저장되는 메모리 영역입니다.

```javascript
// 객체는 힙에 저장됨
const person = { name: "철수", age: 30 };
const numbers = [1, 2, 3, 4, 5];
const func = function () {
  console.log("함수");
};
```

**특징:**

- 동적으로 할당된 메모리 영역
- 객체와 참조 타입 데이터 저장
- 가비지 컬렉션(Garbage Collection)으로 관리

### Call Stack (콜 스택)

**콜 스택**은 함수 호출이 쌓이는 스택 구조입니다. JavaScript는 단일 스레드이므로 하나의 콜 스택만 존재합니다.

```javascript
function first() {
  console.log("첫 번째 함수");
  second();
}

function second() {
  console.log("두 번째 함수");
  third();
}

function third() {
  console.log("세 번째 함수");
}

first();

// 콜 스택 상태:
// [third]     <- 가장 위
// [second]
// [first]
// [global]    <- 가장 아래
```

**동작 방식:**

1. 함수가 호출되면 콜 스택에 추가됨
2. 함수 실행이 끝나면 콜 스택에서 제거됨
3. 스택이 비어있으면 프로그램 종료

**예시:**

```javascript
function multiply(a, b) {
  return a * b;
}

function add(a, b) {
  const result = multiply(a, b);
  return result + 10;
}

const answer = add(3, 4);
console.log(answer); // 22

// 실행 순서:
// 1. add() 호출 → 콜 스택에 추가
// 2. multiply() 호출 → 콜 스택에 추가
// 3. multiply() 완료 → 콜 스택에서 제거
// 4. add() 완료 → 콜 스택에서 제거
```

### Event Loop (이벤트 루프)

**이벤트 루프**는 콜 스택과 태스크 큐를 연결하는 핵심 메커니즘입니다.

**역할:**

1. 콜 스택이 비어있는지 지속적으로 확인
2. 콜 스택이 비면 태스크 큐에서 대기 중인 작업을 가져와 실행
3. 이 과정을 반복

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");

// 실행 과정:
// 1. console.log("1") → 콜 스택에 추가 후 실행
// 2. setTimeout → Web API로 전달, 콜백은 태스크 큐에 추가
// 3. console.log("3") → 콜 스택에 추가 후 실행
// 4. 콜 스택이 비면 이벤트 루프가 태스크 큐 확인
// 5. 콜백 함수 실행 → console.log("2")

// 출력: 1, 3, 2
```

**이벤트 루프의 동작 원리:**

```
┌─────────────────┐
│   Call Stack    │ ← 함수 실행
└────────┬────────┘
         │
         │ (비어있으면)
         ↓
┌─────────────────┐
│  Event Loop     │ ← 지속적으로 확인
└────────┬────────┘
         │
         │ (작업 가져오기)
         ↓
┌─────────────────┐
│   Task Queue    │ ← 비동기 콜백 대기
└─────────────────┘
```

### Task Queue (태스크 큐)

**태스크 큐**는 비동기 작업의 콜백 함수가 대기하는 큐입니다.

**종류:**

1. **Macrotask Queue (매크로태스크 큐)**

   - `setTimeout`, `setInterval` 콜백
   - 이벤트 핸들러
   - I/O 작업

2. **Microtask Queue (마이크로태스크 큐)**
   - `Promise.then()` 콜백
   - `queueMicrotask()` 콜백
   - `MutationObserver` 콜백

**실행 순서:**

```javascript
console.log("1");

// 매크로태스크
setTimeout(() => console.log("2"), 0);

// 마이크로태스크
Promise.resolve().then(() => console.log("3"));

console.log("4");

// 출력: 1, 4, 3, 2
// 이유: 마이크로태스크가 매크로태스크보다 우선순위가 높음
```

### 전체 실행 흐름 예시

```javascript
console.log("시작");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("끝");

// 실행 흐름:
// 1. 콜 스택: [console.log("시작")] → 실행 → "시작" 출력
// 2. 콜 스택: [setTimeout] → Web API로 전달 → 매크로태스크 큐에 콜백 추가
// 3. 콜 스택: [Promise.resolve().then] → 마이크로태스크 큐에 콜백 추가
// 4. 콜 스택: [console.log("끝")] → 실행 → "끝" 출력
// 5. 콜 스택이 비어있음
// 6. 이벤트 루프: 마이크로태스크 큐 확인 → Promise 콜백 실행 → "Promise" 출력
// 7. 이벤트 루프: 매크로태스크 큐 확인 → setTimeout 콜백 실행 → "setTimeout" 출력

// 최종 출력: 시작, 끝, Promise, setTimeout
```
