# JavaScript 함수

JavaScript에서 함수는 매우 중요한 개념입니다. 함수 선언 방식부터 `this` 바인딩까지 다양한 내용을 정리해보겠습니다.

## 1. 함수 선언 vs 함수 표현식

### 함수 선언(Function Declaration)

```javascript
function sayHello() {
  console.log("안녕하세요!");
}

sayHello(); // "안녕하세요!"
```

**특징:**

- 함수 이름이 필수입니다.
- **호이스팅(Hoisting)**이 발생합니다. 선언 전에 호출 가능합니다.
- 함수 전체가 스코프의 최상단으로 끌어올려집니다.

```javascript
// 함수 선언 전에 호출해도 동작합니다!
greet(); // "안녕하세요!"

function greet() {
  console.log("안녕하세요!");
}
```

### 함수 표현식(Function Expression)

```javascript
const sayGoodbye = function () {
  console.log("안녕히 가세요!");
};

sayGoodbye(); // "안녕히 가세요!"
```

**특징:**

- 변수에 함수를 할당하는 형태입니다.
- 함수 이름은 선택사항입니다(익명 함수 가능).
- 호이스팅이 발생하지 않습니다. 선언 전에 호출하면 에러가 발생합니다.

```javascript
// 에러 발생!
greet(); // TypeError: greet is not a function

const greet = function () {
  console.log("안녕하세요!");
};
```

### 이름이 있는 함수 표현식(Named Function Expression)

```javascript
const factorial = function calculateFactorial(n) {
  if (n <= 1) return 1;
  return n * calculateFactorial(n - 1);
};

console.log(factorial(5)); // 120
// calculateFactorial(5); // ReferenceError (외부에서 접근 불가)
```

함수 내부에서 자기 자신을 참조할 때 유용합니다.

### 언제 무엇을 사용할까?

**함수 선언 사용:**

- 일반적인 함수 정의
- 호이스팅이 필요한 경우
- 재귀 함수

**함수 표현식 사용:**

- 조건부로 함수를 생성할 때
- 콜백 함수로 전달할 때
- 클로저를 만들 때
- 모듈 패턴 구현 시

## 2. 화살표 함수(Arrow Function)

ES6에서 도입된 화살표 함수는 함수를 더 간결하게 작성할 수 있게 해줍니다.

### 기본 문법

```javascript
// 일반 함수
const add1 = function (a, b) {
  return a + b;
};

// 화살표 함수
const add2 = (a, b) => {
  return a + b;
};

// 더 간단하게 (단일 표현식)
const add3 = (a, b) => a + b;

// 매개변수가 하나일 때 괄호 생략 가능
const square = (x) => x * x;

// 매개변수가 없을 때
const greet = () => console.log("안녕하세요!");
```

### 화살표 함수의 특징

#### 1. `this` 바인딩이 다릅니다

```javascript
const obj = {
  name: "철수",
  regularFunction: function () {
    console.log(this.name); // "철수"
  },
  arrowFunction: () => {
    console.log(this.name); // undefined (전역 객체를 참조)
  },
};

obj.regularFunction(); // "철수"
obj.arrowFunction(); // undefined
```

화살표 함수는 자신만의 `this`를 가지지 않고, **상위 스코프의 `this`를 상속**받습니다.

#### 2. `arguments` 객체를 가지지 않습니다

```javascript
function regularFunction() {
  console.log(arguments); // Arguments 객체
}

const arrowFunction = () => {
  console.log(arguments); // ReferenceError
};

// 대신 나머지 매개변수 사용
const arrowFunction2 = (...args) => {
  console.log(args); // 배열
};
```

#### 3. 생성자 함수로 사용할 수 없습니다

```javascript
const Person = (name) => {
  this.name = name; // TypeError: Arrow functions cannot be used as constructors
};

// 일반 함수는 가능
function Person2(name) {
  this.name = name;
}
```

#### 4. `prototype` 속성이 없습니다

```javascript
const arrow = () => {};
console.log(arrow.prototype); // undefined

function regular() {}
console.log(regular.prototype); // { constructor: f }
```

### 화살표 함수 사용 예시

```javascript
// 배열 메서드와 함께 사용
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
const evens = numbers.filter((n) => n % 2 === 0);

// 콜백 함수
setTimeout(() => {
  console.log("1초 후 실행");
}, 1000);

// 이벤트 핸들러 (주의: this 바인딩이 다를 수 있음)
button.addEventListener("click", () => {
  console.log("클릭됨");
});
```

## 3. 렉시컬 환경(Lexical Environment)

### 렉시컬 스코프(Lexical Scope)란?

렉시컬 환경을 이해하기 전에 먼저 **렉시컬 스코프(Lexical Scope)**를 알아야 합니다.

**렉시컬 스코프**: 함수가 **어디서 선언되었는지**에 따라 스코프가 결정되는 방식입니다. JavaScript는 렉시컬 스코프를 사용합니다.

동적 스코프와 달리, 렉시컬 스코프는 함수가 **호출된 위치**가 아니라 **선언된 위치**를 기준으로 스코프를 결정합니다.

```javascript
const x = "전역";

function outer() {
  const x = "외부";

  function inner() {
    console.log(x); // "외부" - 선언된 위치(outer 내부)의 스코프를 따름
  }

  return inner;
}

const innerFunc = outer();
innerFunc(); // "외부" (호출 위치와 무관하게 선언 위치의 스코프를 따름)
```

### 렉시컬 환경의 구조

**렉시컬 환경(Lexical Environment)**은 JavaScript 엔진이 변수와 함수를 관리하는 내부 메커니즘입니다. 다음과 같은 구조를 가집니다:

1. **환경 레코드(Environment Record)**: 변수와 함수 선언을 저장하는 곳

   - 선언적 환경 레코드(Declarative Environment Record): `let`, `const`, `function` 등
   - 객체 환경 레코드(Object Environment Record): `with` 문 등

2. **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**: 외부 스코프를 가리키는 참조
   - **스코프 체인**을 형성하여 변수 검색 경로를 만듭니다.

```javascript
function outer() {
  const a = 1; // outer의 렉시컬 환경에 저장

  function inner() {
    const b = 2; // inner의 렉시컬 환경에 저장
    console.log(a); // 외부 렉시컬 환경 참조를 통해 a에 접근
  }

  return inner;
}
```

### 렉시컬 환경의 동작 방식

이 코드에서:

- `outer` 함수가 실행되면 `outer`의 렉시컬 환경이 생성됩니다.
- `inner` 함수가 선언되면 `inner`의 렉시컬 환경이 생성되고, **외부 렉시컬 환경 참조**가 `outer`의 렉시컬 환경을 가리킵니다.
- `inner` 함수 내부에서 `a`를 참조할 때:
  1. 먼저 자신의 렉시컬 환경(환경 레코드)에서 찾습니다.
  2. 없으면 외부 렉시컬 환경 참조를 따라 `outer`의 렉시컬 환경에서 찾습니다.
  3. 계속 상위로 올라가며 찾습니다 **(스코프 체인)**

### 렉시컬 환경의 구조 예시

```javascript
// 전역 렉시컬 환경
// - 환경 레코드: { globalVar: "전역" }
// - 외부 렉시컬 환경 참조: null (최상위)
const globalVar = "전역";

function outer() {
  // outer의 렉시컬 환경
  // - 환경 레코드: { outerVar: "외부" }
  // - 외부 렉시컬 환경 참조: 전역 렉시컬 환경
  const outerVar = "외부";

  function inner() {
    // inner의 렉시컬 환경
    // - 환경 레코드: { innerVar: "내부" }
    // - 외부 렉시컬 환경 참조: outer의 렉시컬 환경
    const innerVar = "내부";

    console.log(innerVar); // 자신의 환경 레코드에서 찾음
    console.log(outerVar); // 외부 참조를 따라 outer의 환경 레코드에서 찾음
    console.log(globalVar); // 외부 참조를 따라 전역 환경 레코드에서 찾음
  }

  return inner;
}
```

### 실행 컨텍스트와 렉시컬 환경

함수가 실행될 때 **실행 컨텍스트(Execution Context)**가 생성되고, 각 실행 컨텍스트는 자신의 렉시컬 환경을 가집니다.

```javascript
function example() {
  const a = 1;
  const b = 2;

  function inner() {
    const c = 3;
    console.log(a, b, c);
  }

  inner();
}

example();
```

실행 순서:

1. 전역 실행 컨텍스트 생성 → 전역 렉시컬 환경 생성
2. `example` 실행 컨텍스트 생성 → `example` 렉시컬 환경 생성 (외부 참조: 전역)
3. `inner` 실행 컨텍스트 생성 → `inner` 렉시컬 환경 생성 (외부 참조: example)
4. `inner` 실행 완료 → `inner` 실행 컨텍스트 제거
5. `example` 실행 완료 → `example` 실행 컨텍스트 제거

## 4. 클로저(Closure) 개념과 활용

### 클로저란?

**클로저(Closure)**는 함수와 그 함수가 선언된 렉시컬 환경(Lexical Environment)의 조합입니다. 간단히 말해, **내부 함수가 외부 함수의 변수에 접근할 수 있는 것**을 의미합니다.

### 클로저와 렉시컬 환경의 관계

클로저는 렉시컬 환경의 메커니즘을 활용합니다:

```javascript
function createFunction() {
  const name = "철수"; // createFunction의 렉시컬 환경에 저장

  return function () {
    console.log(name); // 외부 렉시컬 환경 참조를 통해 name에 접근
  };
}

const myFunc = createFunction();
// createFunction의 실행이 끝났지만,
// 반환된 함수는 여전히 createFunction의 렉시컬 환경을 참조하고 있습니다.
// 이것이 클로저입니다!

myFunc(); // "철수"
```

**핵심 포인트:**

- 함수가 선언될 때의 렉시컬 환경이 "기억"됩니다.
- 외부 함수가 실행을 마쳐도, 내부 함수가 외부 함수의 렉시컬 환경을 참조하고 있으면 그 환경은 메모리에 남아있습니다.
- 이것이 클로저가 외부 변수에 접근할 수 있는 이유입니다.

### 기본 예시

```javascript
function outerFunction() {
  const outerVariable = "외부 변수";

  function innerFunction() {
    console.log(outerVariable); // 외부 함수의 변수에 접근
  }

  return innerFunction;
}

const myFunction = outerFunction();
myFunction(); // "외부 변수"
```

`outerFunction`이 실행을 마쳤지만, `innerFunction`은 여전히 `outerVariable`에 접근할 수 있습니다.

### 클로저의 활용

#### 1. 데이터 은닉(Private 변수)

```javascript
function createCounter() {
  let count = 0; // private 변수

  return {
    increment: function () {
      count++;
      return count;
    },
    decrement: function () {
      count--;
      return count;
    },
    getCount: function () {
      return count;
    },
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
// count 변수에 직접 접근 불가능 (은닉됨)
```

#### 2. 함수 팩토리

```javascript
function createMultiplier(multiplier) {
  return function (number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

#### 3. 반복문과 클로저 (클래식한 문제)

```javascript
// 문제가 있는 코드
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 3, 3, 3 (의도와 다름!)
  }, 100);
}

// 해결 방법 1: let 사용
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2
  }, 100);
}

// 해결 방법 2: IIFE 사용
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j); // 0, 1, 2
    }, 100);
  })(i);
}
```

#### 4. 메모이제이션(Memoization)

```javascript
function memoize(fn) {
  const cache = {}; // 클로저로 캐시 저장

  return function (...args) {
    const key = JSON.stringify(args);
    if (cache[key]) {
      return cache[key];
    }
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensiveFunction = memoize(function (n) {
  console.log("계산 중...");
  return n * n;
});

console.log(expensiveFunction(5)); // 계산 중... 25
console.log(expensiveFunction(5)); // 25 (캐시에서 가져옴)
```

### 클로저 주의사항

```javascript
// 메모리 누수 가능성
function attachEvent() {
  const largeData = new Array(1000000).fill("데이터");

  document.getElementById("button").addEventListener("click", function () {
    console.log("클릭됨");
    // largeData를 참조하지 않지만 클로저로 인해 메모리에 남아있을 수 있음
  });
}
```

불필요한 클로저는 메모리 누수를 일으킬 수 있으므로 주의해야 합니다.

## 5. `this` 키워드의 바인딩과 동작 방식

### `this`란?

`this`는 함수가 호출되는 방식에 따라 동적으로 결정되는 특별한 키워드입니다. 함수가 **어떻게 호출되었는지**에 따라 값이 달라집니다.

### `this` 바인딩 규칙

#### 1. 기본 바인딩 (Default Binding)

함수를 일반 함수로 호출하면 `this`는 전역 객체를 가리킵니다.

```javascript
function showThis() {
  console.log(this); // window (브라우저) 또는 global (Node.js)
}

showThis();

// 엄격 모드에서는 undefined
function showThisStrict() {
  "use strict";
  console.log(this); // undefined
}

showThisStrict();
```

#### 2. 암시적 바인딩 (Implicit Binding)

객체의 메서드로 호출하면 `this`는 그 객체를 가리킵니다.

```javascript
const person = {
  name: "철수",
  greet: function () {
    console.log(`안녕하세요, ${this.name}입니다.`);
  },
};

person.greet(); // "안녕하세요, 철수입니다."
```

**주의**: 메서드를 변수에 할당하면 `this`가 사라집니다.

```javascript
const greet = person.greet;
greet(); // "안녕하세요, undefined입니다." (this가 전역 객체를 가리킴)
```

#### 3. 명시적 바인딩 (Explicit Binding)

`call`, `apply`, `bind`를 사용하여 `this`를 명시적으로 지정합니다.

```javascript
function introduce() {
  console.log(`안녕하세요, ${this.name}입니다.`);
}

const person1 = { name: "철수" };
const person2 = { name: "영희" };

introduce.call(person1); // "안녕하세요, 철수입니다."
introduce.call(person2); // "안녕하세요, 영희입니다."
```

#### 4. `new` 바인딩 (Constructor Binding)

생성자 함수로 호출하면 `this`는 새로 생성된 객체를 가리킵니다.

```javascript
function Person(name) {
  this.name = name;
}

const person = new Person("철수");
console.log(person.name); // "철수"
```

### `this` 바인딩 우선순위

1. `new` 바인딩 (가장 높음)
2. 명시적 바인딩 (`call`, `apply`, `bind`)
3. 암시적 바인딩 (메서드 호출)
4. 기본 바인딩 (가장 낮음)

### 화살표 함수의 `this`

화살표 함수는 `this`를 바인딩하지 않고, **상위 스코프의 `this`를 상속**받습니다.
화살표 함수 밖에서 **제일 근접한 스코프**의 `this`를 가리킵니다.

```javascript
const obj = {
  name: "철수",
  regularMethod: function () {
    console.log(this.name); // "철수"

    setTimeout(function () {
      console.log(this.name); // undefined (this가 전역 객체)
    }, 100);

    setTimeout(() => {
      console.log(this.name); // "철수" (상위 스코프의 this 상속)
    }, 100);
  },
};

obj.regularMethod();
```

---

### 일반 함수 vs 화살표 함수 비교

일반 함수와 화살표 함수의 주요 차이점을 표로 정리했습니다.

| 특징                        | 일반 함수                                            | 화살표 함수                                            |
| --------------------------- | ---------------------------------------------------- | ------------------------------------------------------ |
| **`this` 바인딩**           | 호출 방식에 따라 동적으로 결정                       | 상위 스코프의 `this`를 상속 (렉시컬 `this`)            |
| **`arguments` 객체**        | 사용 가능                                            | 사용 불가 (나머지 매개변수 `...args` 사용)             |
| **생성자 함수**             | 사용 가능 (`new` 키워드)                             | 사용 불가 (`TypeError` 발생)                           |
| **`prototype` 속성**        | 있음                                                 | 없음 (`undefined`)                                     |
| **호이스팅**                | 함수 선언: 호이스팅됨<br>함수 표현식: 호이스팅 안 됨 | 호이스팅 안 됨 (함수 표현식과 동일)                    |
| **`call`, `apply`, `bind`** | `this` 바인딩 변경 가능                              | `this` 바인딩 변경 불가 (무시됨)                       |
| **메서드로 사용**           | 객체의 메서드로 사용 시 `this`가 객체를 가리킴       | 객체의 메서드로 사용해도 `this`는 상위 스코프를 가리킴 |
| **문법**                    | `function name() {}` 또는 `const fn = function() {}` | `const fn = () => {}`                                  |

#### 상세 설명

**1. `this` 바인딩**

```javascript
const obj = {
  name: "철수",
  regularFunction: function () {
    console.log(this.name); // "철수" - obj를 가리킴
  },
  arrowFunction: () => {
    console.log(this.name); // undefined - 상위 스코프(전역)를 가리킴
  },
};
```

**2. `arguments` 객체**

```javascript
function regular() {
  console.log(arguments); // Arguments(3) [1, 2, 3]
}

const arrow = () => {
  console.log(arguments); // ReferenceError
};

const arrow2 = (...args) => {
  console.log(args); // [1, 2, 3] - 배열
};
```

**3. 생성자 함수**

```javascript
// 일반 함수 - 가능
function Person(name) {
  this.name = name;
}
const person = new Person("철수"); // ✅ 작동

// 화살표 함수 - 불가능
const Person2 = (name) => {
  this.name = name;
};
const person2 = new Person2("철수"); // ❌ TypeError
```

**4. `call`, `apply`, `bind`와의 관계**

```javascript
function regular() {
  console.log(this.name);
}

const arrow = () => {
  console.log(this.name);
};

const obj = { name: "철수" };

regular.call(obj); // "철수" - this가 obj로 바인딩됨
arrow.call(obj); // undefined - this 바인딩이 무시됨 (상위 스코프 유지)
```

**5. 메서드로 사용할 때**

```javascript
const obj = {
  name: "철수",
  regularMethod: function () {
    return this.name;
  },
  arrowMethod: () => {
    return this.name;
  },
};

console.log(obj.regularMethod()); // "철수"
console.log(obj.arrowMethod()); // undefined (전역 스코프)
```

#### 언제 무엇을 사용할까?

**일반 함수 사용:**

- 객체의 메서드를 정의할 때
- 생성자 함수를 만들 때
- `this` 바인딩이 필요한 경우
- `arguments` 객체가 필요한 경우

**화살표 함수 사용:**

- 콜백 함수로 사용할 때 (특히 `this` 바인딩 문제 해결)
- 배열 메서드(`map`, `filter`, `reduce` 등)와 함께 사용
- 짧은 함수를 간결하게 작성할 때
- 상위 스코프의 `this`를 유지해야 할 때

---

## 6. `call`, `apply`, `bind`의 차이점

이 세 메서드는 모두 함수의 `this`를 명시적으로 바인딩하는데 사용되지만, 동작 방식이 다릅니다.

### `call` 메서드

함수를 즉시 호출하며, `this`와 인수들을 전달합니다.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "철수" };

greet.call(person, "안녕하세요", "!"); // "안녕하세요, 철수!"
```

**특징:**

- 함수를 즉시 실행합니다.
- 인수들을 **개별적으로** 전달합니다.
- 첫 번째 인수는 `this`로 바인딩할 객체입니다.

### `apply` 메서드

`call`과 유사하지만, 인수들을 **배열**로 전달합니다.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "철수" };

greet.apply(person, ["안녕하세요", "!"]); // "안녕하세요, 철수!"
```

**특징:**

- 함수를 즉시 실행합니다.
- 인수들을 **배열**로 전달합니다.
- 동적 인수 개수에 유용합니다.

```javascript
// 배열의 최대값 찾기
const numbers = [5, 6, 2, 3, 7];
const max = Math.max.apply(null, numbers); // 7
// 또는 스프레드 연산자 사용
const max2 = Math.max(...numbers); // 7
```

### `bind` 메서드

함수를 호출하지 않고, `this`가 바인딩된 **새로운 함수**를 반환합니다.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const person = { name: "철수" };
const boundGreet = greet.bind(person);

boundGreet("안녕하세요", "!"); // "안녕하세요, 철수!"
```

**특징:**

- 함수를 즉시 실행하지 않습니다.
- `this`가 바인딩된 새로운 함수를 반환합니다.
- 나중에 호출할 수 있습니다.

### 부분 적용(Partial Application)

`bind`는 인수도 미리 고정할 수 있습니다.

```javascript
function multiply(a, b, c) {
  return a * b * c;
}

const multiplyByTwo = multiply.bind(null, 2);
console.log(multiplyByTwo(3, 4)); // 24 (2 * 3 * 4)

const multiplyByTwoAndThree = multiply.bind(null, 2, 3);
console.log(multiplyByTwoAndThree(4)); // 24 (2 * 3 * 4)
```

### 비교 표

| 메서드  | 즉시 실행 | 인수 전달 방식     | 반환값         |
| ------- | --------- | ------------------ | -------------- |
| `call`  | ✅ 예     | 개별 인수          | 함수 실행 결과 |
| `apply` | ✅ 예     | 배열               | 함수 실행 결과 |
| `bind`  | ❌ 아니오 | 개별 인수 (선택적) | 새로운 함수    |

### 실전 활용 예시

```javascript
// 1. 유사 배열 객체를 배열로 변환
const arrayLike = { 0: "a", 1: "b", 2: "c", length: 3 };
const realArray = Array.prototype.slice.call(arrayLike);
console.log(realArray); // ["a", "b", "c"]

// 2. 이벤트 핸들러에서 this 바인딩
class Button {
  constructor(text) {
    this.text = text;
    this.element = document.createElement("button");
    this.element.textContent = text;
    // bind를 사용하여 this 보존
    this.element.addEventListener("click", this.handleClick.bind(this));
  }

  handleClick() {
    console.log(`버튼 "${this.text}"이 클릭되었습니다.`);
  }
}

// 3. 함수 빌려쓰기 (Method Borrowing)
const person = {
  firstName: "철수",
  lastName: "김",
};

function introduce(greeting) {
  console.log(`${greeting}, ${this.firstName} ${this.lastName}입니다.`);
}

introduce.call(person, "안녕하세요"); // "안녕하세요, 철수 김입니다."
```

## 요약

- **함수 선언**: 호이스팅됨, 함수 이름 필수
- **함수 표현식**: 호이스팅 안 됨, 변수에 할당
- **화살표 함수**: `this` 바인딩 없음, 상위 스코프의 `this` 상속
- **클로저**: 내부 함수가 외부 함수의 변수에 접근, 데이터 은닉에 유용
- **`this`**: 호출 방식에 따라 동적으로 결정
- **`call`**: 즉시 실행, 개별 인수
- **`apply`**: 즉시 실행, 배열 인수
- **`bind`**: 새 함수 반환, 나중에 호출 가능
