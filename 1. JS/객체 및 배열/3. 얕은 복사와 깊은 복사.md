# 얕은 복사 vs 깊은 복사

JavaScript에서 객체와 배열을 복사할 때 얕은 복사와 깊은 복사의 차이를 이해하는 것이 중요합니다.

## 1. 얕은 복사(Shallow Copy)

얕은 복사는 최상위 레벨만 복사하고, 중첩된 객체나 배열은 참조를 공유합니다.

```javascript
// 객체 얕은 복사
const original = {
  name: "철수",
  age: 30,
  address: {
    city: "서울",
    country: "한국",
  },
};

// 방법 1: 스프레드 연산자
const shallow1 = { ...original };

// 방법 2: Object.assign()
const shallow2 = Object.assign({}, original);

// 방법 3: 배열의 경우
const arr = [1, 2, [3, 4]];
const shallowArr = [...arr];

// 문제: 중첩된 객체는 참조를 공유
shallow1.address.city = "부산";
console.log(original.address.city); // "부산" - 원본도 변경됨!

shallowArr[2][0] = 999;
console.log(arr[2][0]); // 999 - 원본도 변경됨!
```

**특징:**

- 최상위 레벨만 복사
- 중첩된 객체/배열은 참조 공유
- 원본의 중첩 구조 변경 시 복사본도 영향받음

## 2. 깊은 복사(Deep Copy)

깊은 복사는 모든 레벨을 완전히 복사하여 독립적인 객체를 만듭니다.

```javascript
const original = {
  name: "철수",
  age: 30,
  address: {
    city: "서울",
    country: "한국",
  },
};

// 방법 1: JSON.parse(JSON.stringify()) - 가장 간단하지만 제한적
const deep1 = JSON.parse(JSON.stringify(original));
deep1.address.city = "부산";
console.log(original.address.city); // "서울" - 원본은 변경되지 않음

// 주의: 함수, undefined, Symbol, Date 등은 복사되지 않음
const obj = {
  name: "철수",
  date: new Date(),
  func: function () {},
};
const deep2 = JSON.parse(JSON.stringify(obj));
console.log(deep2.date); // 문자열로 변환됨
console.log(deep2.func); // undefined

// 방법 2: 재귀 함수 사용
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj);
  }

  if (obj instanceof Array) {
    return obj.map((item) => deepCopy(item));
  }

  if (typeof obj === "object") {
    const copy = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        copy[key] = deepCopy(obj[key]);
      }
    }
    return copy;
  }
}

// 방법 3: structuredClone() (최신 브라우저)
// const deep3 = structuredClone(original);
```

**특징:**

- 모든 레벨을 완전히 복사
- 원본과 완전히 독립적
- 중첩 구조 변경 시 원본에 영향 없음

## 3. 언제 무엇을 사용할까?

**얕은 복사 사용:**

- 단순한 객체/배열 (중첩 구조 없음)
- 성능이 중요한 경우
- 원본과 복사본이 일부 공유되어도 괜찮은 경우

**깊은 복사 사용:**

- 중첩된 객체/배열이 있는 경우
- 원본을 완전히 보호해야 하는 경우
- 복잡한 데이터 구조
