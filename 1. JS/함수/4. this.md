## 1. this란?

**`this`**는 JavaScript에서 함수가 호출되는 방식에 따라 동적으로 결정되는 특별한 키워드입니다. `this`는 함수가 **어디서 호출되었는지**에 따라 그 값이 달라집니다.

**핵심 포인트:**

- `this`는 함수가 **선언된 위치**가 아니라 **호출된 방식**에 따라 결정됩니다.
- 같은 함수라도 호출 방식이 다르면 `this` 값이 달라질 수 있습니다.

## 2. this가 결정되는 상황들

### 1. 일반 함수 호출 (기본 바인딩)

일반 함수로 호출하면 `this`는 **전역 객체**를 가리킵니다.

- 브라우저: `window`
- Node.js: `global`

```javascript
function showThis() {
  console.log(this); // 전역 객체 (브라우저: window, Node.js: global)
}

showThis(); // window (또는 global)
```

```javascript
const obj = {
  name: "철수",
  sayHello: function () {
    function inner() {
      console.log(this); // window (일반 함수 호출)
    }
    inner();
  },
};

obj.sayHello(); // window
```

### 2. 메서드 호출 (암시적 바인딩)

객체의 메서드로 호출하면 `this`는 **그 객체**를 가리킵니다.

```javascript
const person = {
  name: "영희",
  greet: function () {
    console.log(`안녕하세요, ${this.name}입니다!`);
  },
};

person.greet(); // "안녕하세요, 영희입니다!"
// this는 person 객체를 가리킵니다
```

```javascript
const dog = {
  name: "멍멍이",
  bark: function () {
    console.log(`${this.name}가 짖습니다: 멍멍!`);
  },
};

dog.bark(); // "멍멍이가 짖습니다: 멍멍!"
```

**주의사항:** 메서드를 변수에 할당하면 일반 함수 호출이 됩니다!

```javascript
const person = {
  name: "철수",
  greet: function () {
    console.log(this.name);
  },
};

const greetFunc = person.greet; // 메서드를 변수에 할당
greetFunc(); // undefined (this가 전역 객체를 가리킴)
// person.greet()가 아니라 일반 함수로 호출되었기 때문
```

### 3. 생성자 함수 호출 (new 바인딩)

`new` 키워드로 함수를 호출하면 `this`는 **새로 생성된 객체**를 가리킵니다.

```javascript
function Person(name) {
  this.name = name; // this는 새로 생성될 객체
  this.greet = function () {
    console.log(`안녕하세요, ${this.name}입니다!`);
  };
}

const person1 = new Person("철수");
const person2 = new Person("영희");

person1.greet(); // "안녕하세요, 철수입니다!"
person2.greet(); // "안녕하세요, 영희입니다!"
```

```javascript
function Car(brand) {
  this.brand = brand;
  this.start = function () {
    console.log(`${this.brand}가 출발합니다!`);
  };
}

const myCar = new Car("현대");
myCar.start(); // "현대가 출발합니다!"
```

### 4. 명시적 바인딩 (call, apply, bind)

`call`, `apply`, `bind` 메서드를 사용하면 `this`를 명시적으로 지정할 수 있습니다.

#### call과 apply

```javascript
function introduce(greeting, punctuation) {
  console.log(`${greeting}, 저는 ${this.name}입니다${punctuation}`);
}

const person1 = { name: "철수" };
const person2 = { name: "영희" };

// call: 인수를 개별적으로 전달
introduce.call(person1, "안녕하세요", "!"); // "안녕하세요, 저는 철수입니다!"
introduce.call(person2, "반갑습니다", "."); // "반갑습니다, 저는 영희입니다."

// apply: 인수를 배열로 전달
introduce.apply(person1, ["안녕하세요", "!"]); // "안녕하세요, 저는 철수입니다!"
introduce.apply(person2, ["반갑습니다", "."]); // "반갑습니다, 저는 영희입니다."
```

#### bind

`bind`는 `this`가 고정된 새로운 함수를 반환합니다.

```javascript
function greet() {
  console.log(`안녕하세요, ${this.name}입니다!`);
}

const person = { name: "철수" };
const boundGreet = greet.bind(person); // this가 person으로 고정된 함수

boundGreet(); // "안녕하세요, 철수입니다!"

// 다른 객체로 호출해도 this는 person으로 고정
const otherPerson = { name: "영희" };
boundGreet.call(otherPerson); // 여전히 "안녕하세요, 철수입니다!"
```

```javascript
const person = {
  name: "철수",
  greet: function () {
    console.log(this.name);
  },
};

// 메서드를 변수에 할당할 때 bind 사용
const greetFunc = person.greet.bind(person);
greetFunc(); // "철수" (this가 person으로 고정됨)
```

### 5. 화살표 함수

화살표 함수는 **자신의 `this`를 가지지 않습니다**. 대신 **상위 스코프의 `this`**를 그대로 사용합니다 (렉시컬 바인딩).

```javascript
const person = {
  name: "철수",
  greet: function () {
    // 일반 함수: this는 person
    console.log("일반 함수:", this.name);

    // 화살표 함수: 상위 스코프(person)의 this를 사용
    const arrowFunc = () => {
      console.log("화살표 함수:", this.name);
    };
    arrowFunc();
  },
};

person.greet();
// "일반 함수: 철수"
// "화살표 함수: 철수"
```

```javascript
const person = {
  name: "철수",
  greet: function () {
    // 일반 함수 내부의 일반 함수
    function normalFunc() {
      console.log(this); // window (일반 함수 호출)
    }

    // 일반 함수 내부의 화살표 함수
    const arrowFunc = () => {
      console.log(this); // person (상위 스코프의 this)
    };

    normalFunc();
    arrowFunc();
  },
};

person.greet();
// window
// { name: '철수', greet: [Function: greet] }
```

**화살표 함수의 특징:**

- `call`, `apply`, `bind`로 `this`를 변경할 수 없습니다.
- 생성자 함수로 사용할 수 없습니다 (`new` 불가).

```javascript
const arrowFunc = () => {
  console.log(this);
};

const obj = { name: "테스트" };

arrowFunc.call(obj); // window (this가 변경되지 않음)
```

### 6. 이벤트 핸들러

이벤트 핸들러에서 `this`는 **이벤트가 발생한 요소**를 가리킵니다.

```javascript
// HTML: <button id="myButton">클릭</button>

const button = document.getElementById("myButton");

button.addEventListener("click", function () {
  console.log(this); // <button id="myButton">클릭</button>
  console.log(this.textContent); // "클릭"
});
```

**주의:** 화살표 함수를 사용하면 `this`가 전역 객체를 가리킵니다!

```javascript
button.addEventListener("click", () => {
  console.log(this); // window (상위 스코프의 this)
  // this.textContent는 undefined
});
```

### 7. strict mode

strict mode에서는 일반 함수 호출 시 `this`가 `undefined`가 됩니다.

```javascript
"use strict";

function showThis() {
  console.log(this); // undefined (strict mode)
}

showThis();
```

```javascript
"use strict";

const obj = {
  name: "철수",
  greet: function () {
    function inner() {
      console.log(this); // undefined (strict mode)
    }
    inner();
  },
};

obj.greet();
```

## 3. this 우선순위

여러 규칙이 동시에 적용될 때의 우선순위:

1. **new 바인딩** (최우선)
2. **명시적 바인딩** (call, apply, bind)
3. **암시적 바인딩** (메서드 호출)
4. **기본 바인딩** (일반 함수 호출)

```javascript
function greet() {
  console.log(this.name);
}

const obj1 = { name: "철수" };
const obj2 = { name: "영희" };

// 명시적 바인딩이 암시적 바인딩보다 우선
obj1.greet.call(obj2); // "영희" (call이 우선)
```

## 4. 실전 예제

### 예제 1: 메서드 분리 문제

```javascript
const calculator = {
  value: 0,
  add: function (num) {
    this.value += num;
    return this;
  },
  multiply: function (num) {
    this.value *= num;
    return this;
  },
  getValue: function () {
    return this.value;
  },
};

calculator.add(5).multiply(2);
console.log(calculator.getValue()); // 10

// 문제: 메서드를 변수에 할당하면 this가 사라짐
const add = calculator.add;
add(3); // this가 전역 객체를 가리킴 (또는 undefined in strict mode)

// 해결: bind 사용
const boundAdd = calculator.add.bind(calculator);
boundAdd(3);
console.log(calculator.getValue()); // 13
```

### 예제 2: 콜백 함수에서의 this

```javascript
class Timer {
  constructor() {
    this.seconds = 0;
  }

  start() {
    // 문제: 일반 함수는 this가 전역 객체를 가리킴
    setInterval(function () {
      this.seconds++; // this가 Timer 인스턴스가 아님!
      console.log(this.seconds);
    }, 1000);
  }

  startFixed() {
    // 해결 1: 화살표 함수 사용
    setInterval(() => {
      this.seconds++; // 상위 스코프(Timer 인스턴스)의 this 사용
      console.log(this.seconds);
    }, 1000);
  }

  startFixed2() {
    // 해결 2: bind 사용
    setInterval(
      function () {
        this.seconds++;
        console.log(this.seconds);
      }.bind(this),
      1000
    );
  }

  startFixed3() {
    // 해결 3: 변수에 this 저장
    const self = this;
    setInterval(function () {
      self.seconds++;
      console.log(self.seconds);
    }, 1000);
  }
}
```

### 예제 3: 클래스 메서드

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  // 일반 메서드: this는 인스턴스를 가리킴
  greet() {
    console.log(`안녕하세요, ${this.name}입니다!`);
  }

  // 화살표 함수 메서드: this가 항상 인스턴스를 가리킴
  greetArrow = () => {
    console.log(`안녕하세요, ${this.name}입니다!`);
  };
}

const person = new Person("철수");

const greet1 = person.greet;
greet1(); // 에러 또는 undefined (this가 없음)

const greet2 = person.greetArrow;
greet2(); // "안녕하세요, 철수입니다!" (this가 인스턴스로 고정됨)
```

## 5. 정리

| 호출 방식      | this 값                                    | 예시                             |
| -------------- | ------------------------------------------ | -------------------------------- |
| 일반 함수 호출 | 전역 객체 (또는 strict mode에서 undefined) | `func()`                         |
| 메서드 호출    | 호출한 객체                                | `obj.method()`                   |
| 생성자 함수    | 새로 생성된 객체                           | `new Func()`                     |
| call/apply     | 첫 번째 인수로 전달된 객체                 | `func.call(obj)`                 |
| bind           | bind에 전달된 객체 (고정)                  | `func.bind(obj)()`               |
| 화살표 함수    | 상위 스코프의 this                         | `() => {}`                       |
| 이벤트 핸들러  | 이벤트가 발생한 요소                       | `button.onclick = function() {}` |

**핵심 요약:**

- `this`는 함수 호출 방식에 따라 결정됩니다.
- 화살표 함수는 자신의 `this`가 없고 상위 스코프의 `this`를 사용합니다.
- 메서드를 변수에 할당할 때는 `bind`를 사용하거나 화살표 함수를 고려하세요.
- 콜백 함수에서 `this`를 유지하려면 화살표 함수나 `bind`를 사용하세요.
