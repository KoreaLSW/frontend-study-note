# JavaScript 함수

JavaScript에서 함수는 매우 중요한 개념입니다. 함수 선언 방식부터 `this` 바인딩까지 다양한 내용을 정리해보겠습니다.

## 1. 함수 선언 vs 함수 표현식

### 함수 선언(Function Declaration)

```javascript
function sayHello() {
  console.log("안녕하세요!");
}

sayHello(); // "안녕하세요!"
```

**특징:**

- 함수 이름이 필수입니다.
- **호이스팅(Hoisting)**이 발생합니다. 선언 전에 호출 가능합니다.
- 함수 전체가 스코프의 최상단으로 끌어올려집니다.

```javascript
// 함수 선언 전에 호출해도 동작합니다!
greet(); // "안녕하세요!"

function greet() {
  console.log("안녕하세요!");
}
```

### 함수 표현식(Function Expression)

```javascript
const sayGoodbye = function () {
  console.log("안녕히 가세요!");
};

sayGoodbye(); // "안녕히 가세요!"
```

**특징:**

- 변수에 함수를 할당하는 형태입니다.
- 함수 이름은 선택사항입니다(익명 함수 가능).
- 호이스팅이 발생하지 않습니다. 선언 전에 호출하면 에러가 발생합니다.

```javascript
// 에러 발생!
greet(); // TypeError: greet is not a function

const greet = function () {
  console.log("안녕하세요!");
};
```

### 이름이 있는 함수 표현식(Named Function Expression)

```javascript
const factorial = function calculateFactorial(n) {
  if (n <= 1) return 1;
  return n * calculateFactorial(n - 1);
};

console.log(factorial(5)); // 120
// calculateFactorial(5); // ReferenceError (외부에서 접근 불가)
```

함수 내부에서 자기 자신을 참조할 때 유용합니다.

### 언제 무엇을 사용할까?

**함수 선언 사용:**

- 일반적인 함수 정의
- 호이스팅이 필요한 경우
- 재귀 함수

**함수 표현식 사용:**

- 조건부로 함수를 생성할 때
- 콜백 함수로 전달할 때
- 클로저를 만들 때
- 모듈 패턴 구현 시

## 2. 화살표 함수(Arrow Function)

ES6에서 도입된 화살표 함수는 함수를 더 간결하게 작성할 수 있게 해줍니다.

### 기본 문법

```javascript
// 일반 함수
const add1 = function (a, b) {
  return a + b;
};

// 화살표 함수
const add2 = (a, b) => {
  return a + b;
};

// 더 간단하게 (단일 표현식)
const add3 = (a, b) => a + b;

// 매개변수가 하나일 때 괄호 생략 가능
const square = (x) => x * x;

// 매개변수가 없을 때
const greet = () => console.log("안녕하세요!");
```

### 화살표 함수의 특징

#### 1. `this` 바인딩이 다릅니다

```javascript
const obj = {
  name: "철수",
  regularFunction: function () {
    console.log(this.name); // "철수"
  },
  arrowFunction: () => {
    console.log(this.name); // undefined (전역 객체를 참조)
  },
};

obj.regularFunction(); // "철수"
obj.arrowFunction(); // undefined
```

화살표 함수는 자신만의 `this`를 가지지 않고, **상위 스코프의 `this`를 상속**받습니다.

#### 2. `arguments` 객체를 가지지 않습니다

```javascript
function regularFunction() {
  console.log(arguments); // Arguments 객체
}

const arrowFunction = () => {
  console.log(arguments); // ReferenceError
};

// 대신 나머지 매개변수 사용
const arrowFunction2 = (...args) => {
  console.log(args); // 배열
};
```

#### 3. 생성자 함수로 사용할 수 없습니다

```javascript
const Person = (name) => {
  this.name = name; // TypeError: Arrow functions cannot be used as constructors
};

// 일반 함수는 가능
function Person2(name) {
  this.name = name;
}
```

#### 4. `prototype` 속성이 없습니다

```javascript
const arrow = () => {};
console.log(arrow.prototype); // undefined

function regular() {}
console.log(regular.prototype); // { constructor: f }
```

### 화살표 함수 사용 예시

```javascript
// 배열 메서드와 함께 사용
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
const evens = numbers.filter((n) => n % 2 === 0);

// 콜백 함수
setTimeout(() => {
  console.log("1초 후 실행");
}, 1000);

// 이벤트 핸들러 (주의: this 바인딩이 다를 수 있음)
button.addEventListener("click", () => {
  console.log("클릭됨");
});
```
