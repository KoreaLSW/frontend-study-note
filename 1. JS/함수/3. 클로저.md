## 1. 클로저(Closure) 개념과 활용

### 클로저란?

**클로저(Closure)**는 함수와 그 함수가 선언된 렉시컬 환경(Lexical Environment)의 조합입니다. 간단히 말해, **내부 함수가 외부 함수의 변수에 접근할 수 있는 것**을 의미합니다.

### 클로저와 렉시컬 환경의 관계

클로저는 렉시컬 환경의 메커니즘을 활용합니다:

```javascript
function createFunction() {
  const name = "철수"; // createFunction의 렉시컬 환경에 저장

  return function () {
    console.log(name); // 외부 렉시컬 환경 참조를 통해 name에 접근
  };
}

const myFunc = createFunction();
// createFunction의 실행이 끝났지만,
// 반환된 함수는 여전히 createFunction의 렉시컬 환경을 참조하고 있습니다.
// 이것이 클로저입니다!

myFunc(); // "철수"
```

**핵심 포인트:**

- 함수가 선언될 때의 렉시컬 환경이 "기억"됩니다.
- 외부 함수가 실행을 마쳐도, 내부 함수가 외부 함수의 렉시컬 환경을 참조하고 있으면 그 환경은 메모리에 남아있습니다.
- 이것이 클로저가 외부 변수에 접근할 수 있는 이유입니다.

### 기본 예시

```javascript
function outerFunction() {
  const outerVariable = "외부 변수";

  function innerFunction() {
    console.log(outerVariable); // 외부 함수의 변수에 접근
  }

  return innerFunction;
}

const myFunction = outerFunction();
myFunction(); // "외부 변수"
```

`outerFunction`이 실행을 마쳤지만, `innerFunction`은 여전히 `outerVariable`에 접근할 수 있습니다.

### 클로저의 활용

#### 1. 데이터 은닉(Private 변수)

```javascript
function createCounter() {
  let count = 0; // private 변수

  return {
    increment: function () {
      count++;
      return count;
    },
    decrement: function () {
      count--;
      return count;
    },
    getCount: function () {
      return count;
    },
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
// count 변수에 직접 접근 불가능 (은닉됨)
```

#### 2. 함수 팩토리

```javascript
function createMultiplier(multiplier) {
  return function (number) {
    return number * multiplier;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

#### 3. 반복문과 클로저 (클래식한 문제)

```javascript
// 문제가 있는 코드
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 3, 3, 3 (의도와 다름!)
  }, 100);
}

// 해결 방법 1: let 사용
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i); // 0, 1, 2
  }, 100);
}

// 해결 방법 2: IIFE 사용
for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(function () {
      console.log(j); // 0, 1, 2
    }, 100);
  })(i);
}
```

#### 4. 메모이제이션(Memoization)

```javascript
function memoize(fn) {
  const cache = {}; // 클로저로 캐시 저장

  return function (...args) {
    const key = JSON.stringify(args);
    if (cache[key]) {
      return cache[key];
    }
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensiveFunction = memoize(function (n) {
  console.log("계산 중...");
  return n * n;
});

console.log(expensiveFunction(5)); // 계산 중... 25
console.log(expensiveFunction(5)); // 25 (캐시에서 가져옴)
```

### 클로저 주의사항

```javascript
// 메모리 누수 가능성
function attachEvent() {
  const largeData = new Array(1000000).fill("데이터");

  document.getElementById("button").addEventListener("click", function () {
    console.log("클릭됨");
    // largeData를 참조하지 않지만 클로저로 인해 메모리에 남아있을 수 있음
  });
}
```

불필요한 클로저는 메모리 누수를 일으킬 수 있으므로 주의해야 합니다.
